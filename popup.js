const api = typeof browser !== 'undefined' ? browser : chrome;
// Popup ‚Äì i18n + Import/Export (privacy) + Notifications + Auto-Hide Rules
// Import-Button-Logik nach Wunsch:
// - Clipboard leer -> Meldung "Zwischenablage ist leer"
// - Clipboard NICHT leer -> Hinweis "Bitte ‚åò/Strg+V dr√ºcken" + Fokus auf unsichtbares Paste-Ziel
// - Nach CMD/Strg+V: Datei kein JSON -> "Dateiformat ist falsch"; JSON (Datei/Text) -> Import
// Kein Dateipicker.

document.addEventListener('DOMContentLoaded', () => {
  applyI18n();
  loadHiddenOrders();
  loadRules();
  refreshMetaFromPage();

  // orders
  qs('#hide-order')?.addEventListener('click', hideOrder);
  qs('#clear-all')?.addEventListener('click', clearAllOrders);
  qs('#export-list')?.addEventListener('click', () => exportList().catch(() => {}));
  qs('#import-list')?.addEventListener('click', importList);
  qs('#order-number')?.addEventListener('keypress', (e) => { if (e.key === 'Enter') hideOrder(); });

  // rules
  qs('#add-rule')?.addEventListener('click', addRule);

  // Globaler Paste-Handler: reagiert nur auf JSON-Dateien oder eindeutig JSON-Text
  document.addEventListener('paste', handleGlobalPaste, true);
});

// ---- i18n ----
const DOMAIN_LOCALE = {
  'amazon.de': 'de', 'amazon.at': 'de',
  'amazon.com': 'en', 'amazon.co.uk': 'en', 'amazon.ca': 'en', 'amazon.com.au': 'en', 'amazon.sg': 'en',
  'amazon.fr': 'fr', 'amazon.it': 'it', 'amazon.es': 'es', 'amazon.nl': 'nl',
  'amazon.se': 'sv', 'amazon.pl': 'pl', 'amazon.com.tr': 'tr', 'amazon.be': 'nl', 'amazon.com.be': 'nl',
  'amazon.mx': 'es', 'amazon.br': 'pt', 'amazon.ae': 'ar', 'amazon.sa': 'ar', 'amazon.eg': 'ar',
  'amazon.jp': 'ja', 'amazon.in': 'en', 'amazon.cn': 'zh'
};

const I18N = {
  en: {
    title: 'üõí Amazon Order Hider',
    labelOrder: 'Enter order number:',
    placeholder: 'e.g. 123-4567890-1234567',
    btnHide: 'Hide',
    hiddenOrders: 'Hidden orders',
    empty: 'No hidden orders',
    btnShowAll: 'Show all',
    btnImport: 'Import',
    btnExport: 'Export',
    noteEnterOrder: 'Please enter order number',
    noteTooShort: 'Order number too short',
    noteAlready: 'Already hidden',
    noteHidden: 'Order hidden!',
    noteShown: 'Order visible again',
    noteAllShown: 'All orders visible again',
    confirmShowAll: 'Really show all orders again?',
    exportOk: 'List exported!',
    importOk: (n) => `Import successful: ${n} entries`,
    importFail: 'Import failed: invalid file',
    fileErr: 'File read error',
    showBtn: 'Show',
    // rules
    rulesTitle: 'Auto‚ÄëHide rules',
    ruleLabel: 'Hide if product title contains:',
    ruleRegex: 'Use RegExp',
    ruleHelp: 'Example: ^gift.*prime$',
    ruleAdd: 'Add rule',
    rulesList: 'Rules',
    rulesEmpty: 'No rules yet',
    ruleEnabled: 'Enabled',
    ruleTypeContains: 'contains',
    ruleTypeRegex: 'regex',
    ruleDeleted: 'Rule deleted',
    ruleAdded: 'Rule added',
    ruleInvalid: 'Please enter a rule value',
    // neue Meldungen
    clipboardEmpty: 'Clipboard is empty',
    pastePrompt: 'Press ‚åò/Ctrl+V to import JSON',
    invalidFormat: 'Import failed: invalid file format'
  ,
    importNote: 'Copy the JSON to your clipboard before importing.'},
  de: {
    title: 'üõí Amazon Bestellungen verbergen',
    labelOrder: 'Bestellnummer eingeben:',
    placeholder: 'z.‚ÄØB. 123-4567890-1234567',
    btnHide: 'Verbergen',
    hiddenOrders: 'Verborgene Bestellungen',
    empty: 'Keine verborgenen Bestellungen',
    btnShowAll: 'Alle anzeigen',
    btnImport: 'Import',
    btnExport: 'Export',
    noteEnterOrder: 'Bitte Bestellnummer eingeben',
    noteTooShort: 'Bestellnummer zu kurz',
    noteAlready: 'Bereits verborgen',
    noteHidden: 'Bestellung verborgen!',
    noteShown: 'Bestellung wieder sichtbar',
    noteAllShown: 'Alle Bestellungen wieder sichtbar',
    confirmShowAll: 'Alle Bestellungen wirklich wieder anzeigen?',
    exportOk: 'Liste exportiert!',
    importOk: (n) => `Import erfolgreich: ${n} Eintr√§ge`,
    importFail: 'Import fehlgeschlagen: ung√ºltige Datei',
    fileErr: 'Dateilesefehler',
    showBtn: 'Anzeigen',
    // rules
    rulesTitle: 'Auto‚ÄëHide‚ÄëRegeln',
    ruleLabel: 'Ausblenden, wenn Produkttitel enth√§lt:',
    ruleRegex: 'RegExp verwenden',
    ruleHelp: 'Beispiel: ^geschenk.*prime$',
    ruleAdd: 'Regel hinzuf√ºgen',
    rulesList: 'Regeln',
    rulesEmpty: 'Noch keine Regeln',
    ruleEnabled: 'Aktiv',
    ruleTypeContains: 'enth√§lt',
    ruleTypeRegex: 'regex',
    ruleDeleted: 'Regel gel√∂scht',
    ruleAdded: 'Regel hinzugef√ºgt',
    ruleInvalid: 'Bitte einen Regelwert eingeben',
    // neue Meldungen
    clipboardEmpty: 'Zwischenablage ist leer',
    pastePrompt: '‚åò/Strg+V dr√ºcken = JSON import',
    invalidFormat: 'Import fehlgeschlagen: ung√ºltiges Dateiformat'
  ,
    importNote: 'Vor dem Import die JSON in die Zwischenablage kopieren.'},

  // ===== Erg√§nzte Sprachen f√ºr alle DOMAIN_LOCALE-Eintr√§ge =====
  fr: {
  title: 'üõí Masqueur de commandes Amazon',
  labelOrder: 'Saisir le num√©ro de commande :',
  placeholder: 'ex. 123-4567890-1234567',
  btnHide: 'Masquer',
  hiddenOrders: 'Commandes masqu√©es',
  empty: 'Aucune commande masqu√©e',
  btnShowAll: 'Tout afficher',
  btnImport: 'Importer',
  btnExport: 'Exporter',
  noteEnterOrder: 'Veuillez saisir le num√©ro de commande',
  noteTooShort: 'Num√©ro de commande trop court',
  noteAlready: 'D√©j√† masqu√©e',
  noteHidden: 'Commande masqu√©e !',
  noteShown: 'Commande √† nouveau visible',
  noteAllShown: 'Toutes les commandes √† nouveau visibles',
  confirmShowAll: 'Afficher toutes les commandes √† nouveau ?',
  exportOk: 'Liste export√©e !',
  importOk: (n) => `Import r√©ussi : ${n} entr√©es`,
  importFail: '√âchec de l‚Äôimport : fichier invalide',
  fileErr: 'Erreur de lecture du fichier',
  showBtn: 'Afficher',
  // Regeln
  rulesTitle: 'R√®gles de masquage automatique',
  ruleLabel: 'Masquer si le titre du produit contient :',
  ruleRegex: 'Utiliser RegExp',
  ruleHelp: 'Exemple : ^cadeau.*prime$',
  ruleAdd: 'Ajouter une r√®gle',
  rulesList: 'R√®gles',
  rulesEmpty: 'Aucune r√®gle',
  ruleEnabled: 'Activ√©e',
  ruleTypeContains: 'contient',
  ruleTypeRegex: 'regex',
  ruleDeleted: 'R√®gle supprim√©e',
  ruleAdded: 'R√®gle ajout√©e',
  ruleInvalid: 'Veuillez entrer une valeur de r√®gle',
  // neue Keys
  clipboardEmpty: 'Presse-papiers vide',
  pastePrompt: 'Appuyez sur ‚åò/Ctrl+V pour importer JSON',
  invalidFormat: 'Format de fichier invalide'
,
    importNote: 'Avant l‚Äôimport, copiez le JSON dans le presse‚Äëpapiers, puis appuyez sur ‚åò/Ctrl+V.'},
it: {
  title: 'üõí Nascondi ordini Amazon',
  labelOrder: 'Inserisci numero d‚Äôordine:',
  placeholder: 'es. 123-4567890-1234567',
  btnHide: 'Nascondi',
  hiddenOrders: 'Ordini nascosti',
  empty: 'Nessun ordine nascosto',
  btnShowAll: 'Mostra tutti',
  btnImport: 'Importa',
  btnExport: 'Esporta',
  noteEnterOrder: 'Inserisci il numero d‚Äôordine',
  noteTooShort: 'Numero d‚Äôordine troppo corto',
  noteAlready: 'Gi√† nascosto',
  noteHidden: 'Ordine nascosto!',
  noteShown: 'Ordine di nuovo visibile',
  noteAllShown: 'Tutti gli ordini di nuovo visibili',
  confirmShowAll: 'Mostrare di nuovo tutti gli ordini?',
  exportOk: 'Lista esportata!',
  importOk: (n) => `Import riuscito: ${n} voci`,
  importFail: 'Import non riuscito: file non valido',
  fileErr: 'Errore di lettura del file',
  showBtn: 'Mostra',
  rulesTitle: 'Regole di nascondimento automatiche',
  ruleLabel: 'Nascondi se il titolo del prodotto contiene:',
  ruleRegex: 'Usa RegExp',
  ruleHelp: 'Esempio: ^regalo.*prime$',
  ruleAdd: 'Aggiungi regola',
  rulesList: 'Regole',
  rulesEmpty: 'Nessuna regola',
  ruleEnabled: 'Attiva',
  ruleTypeContains: 'contiene',
  ruleTypeRegex: 'regex',
  ruleDeleted: 'Regola eliminata',
  ruleAdded: 'Regola aggiunta',
  ruleInvalid: 'Inserisci un valore per la regola',
  clipboardEmpty: 'Appunti vuoti',
  pastePrompt: 'Premi ‚åò/Ctrl+V per importare JSON',
  invalidFormat: 'Formato file non valido'
,
    importNote: 'Prima di importare, copia il JSON negli appunti e poi premi ‚åò/Ctrl+V.'},
es: {
  title: 'üõí Ocultador de pedidos de Amazon',
  labelOrder: 'Introduce el n√∫mero de pedido:',
  placeholder: 'ej. 123-4567890-1234567',
  btnHide: 'Ocultar',
  hiddenOrders: 'Pedidos ocultos',
  empty: 'No hay pedidos ocultos',
  btnShowAll: 'Mostrar todos',
  btnImport: 'Importar',
  btnExport: 'Exportar',
  noteEnterOrder: 'Introduce el n√∫mero de pedido',
  noteTooShort: 'N√∫mero de pedido demasiado corto',
  noteAlready: 'Ya oculto',
  noteHidden: '¬°Pedido oculto!',
  noteShown: 'Pedido visible de nuevo',
  noteAllShown: 'Todos los pedidos visibles de nuevo',
  confirmShowAll: '¬øMostrar todos los pedidos de nuevo?',
  exportOk: 'Lista exportada',
  importOk: (n) => `Importaci√≥n exitosa: ${n} entradas`,
  importFail: 'Error de importaci√≥n: archivo no v√°lido',
  fileErr: 'Error de lectura de archivo',
  showBtn: 'Mostrar',
  rulesTitle: 'Reglas de ocultaci√≥n autom√°tica',
  ruleLabel: 'Ocultar si el t√≠tulo del producto contiene:',
  ruleRegex: 'Usar RegExp',
  ruleHelp: 'Ejemplo: ^regalo.*prime$',
  ruleAdd: 'A√±adir regla',
  rulesList: 'Reglas',
  rulesEmpty: 'No hay reglas',
  ruleEnabled: 'Activada',
  ruleTypeContains: 'contiene',
  ruleTypeRegex: 'regex',
  ruleDeleted: 'Regla eliminada',
  ruleAdded: 'Regla a√±adida',
  ruleInvalid: 'Introduce un valor para la regla',
  clipboardEmpty: 'Portapapeles vac√≠o',
  pastePrompt: 'Pulsa ‚åò/Ctrl+V para importar JSON',
  invalidFormat: 'Formato de archivo no v√°lido'
,
    importNote: 'Antes de importar, copia el JSON al portapapeles y luego pulsa ‚åò/Ctrl+V.'},
nl: {
  title: 'üõí Amazon-bestellingen verbergen',
  labelOrder: 'Voer bestelnummer in:',
  placeholder: 'bijv. 123-4567890-1234567',
  btnHide: 'Verbergen',
  hiddenOrders: 'Verborgen bestellingen',
  empty: 'Geen verborgen bestellingen',
  btnShowAll: 'Alles tonen',
  btnImport: 'Importeren',
  btnExport: 'Exporteren',
  noteEnterOrder: 'Voer een bestelnummer in',
  noteTooShort: 'Bestelnummer te kort',
  noteAlready: 'Al verborgen',
  noteHidden: 'Bestelling verborgen!',
  noteShown: 'Bestelling weer zichtbaar',
  noteAllShown: 'Alle bestellingen weer zichtbaar',
  confirmShowAll: 'Alle bestellingen opnieuw tonen?',
  exportOk: 'Lijst ge√´xporteerd',
  importOk: (n) => `Import geslaagd: ${n} items`,
  importFail: 'Import mislukt: ongeldig bestand',
  fileErr: 'Fout bij lezen van bestand',
  showBtn: 'Tonen',
  rulesTitle: 'Automatische verbergregels',
  ruleLabel: 'Verberg als de producttitel het volgende bevat:',
  ruleRegex: 'RegExp gebruiken',
  ruleHelp: 'Voorbeeld: ^cadeau.*prime$',
  ruleAdd: 'Regel toevoegen',
  rulesList: 'Regels',
  rulesEmpty: 'Nog geen regels',
  ruleEnabled: 'Ingeschakeld',
  ruleTypeContains: 'bevat',
  ruleTypeRegex: 'regex',
  ruleDeleted: 'Regel verwijderd',
  ruleAdded: 'Regel toegevoegd',
  ruleInvalid: 'Voer een regelwaarde in',
  clipboardEmpty: 'Klembord is leeg',
  pastePrompt: 'Druk op ‚åò/Ctrl+V om JSON te importeren',
  invalidFormat: 'Ongeldig bestandsformaat'
,
    importNote: 'Kopieer v√≥√≥r het importeren de JSON naar je klembord. Druk daarna op ‚åò/Ctrl+V.'},
sv: {
  title: 'üõí D√∂lj Amazon-best√§llningar',
  labelOrder: 'Ange ordernummer:',
  placeholder: 't.ex. 123-4567890-1234567',
  btnHide: 'D√∂lj',
  hiddenOrders: 'Dolda best√§llningar',
  empty: 'Inga dolda best√§llningar',
  btnShowAll: 'Visa alla',
  btnImport: 'Importera',
  btnExport: 'Exportera',
  noteEnterOrder: 'Ange ordernummer',
  noteTooShort: 'Ordernumret √§r f√∂r kort',
  noteAlready: 'Redan dold',
  noteHidden: 'Best√§llning dold!',
  noteShown: 'Best√§llning synlig igen',
  noteAllShown: 'Alla best√§llningar synliga igen',
  confirmShowAll: 'Visa alla best√§llningar igen?',
  exportOk: 'Lista exporterad',
  importOk: (n) => `Import lyckades: ${n} poster`,
  importFail: 'Import misslyckades: ogiltig fil',
  fileErr: 'Fel vid fill√§sning',
  showBtn: 'Visa',
  rulesTitle: 'Regler f√∂r automatisk d√∂ljning',
  ruleLabel: 'D√∂lj om produkttiteln inneh√•ller:',
  ruleRegex: 'Anv√§nd RegExp',
  ruleHelp: 'Exempel: ^present.*prime$',
  ruleAdd: 'L√§gg till regel',
  rulesList: 'Regler',
  rulesEmpty: 'Inga regler',
  ruleEnabled: 'Aktiverad',
  ruleTypeContains: 'inneh√•ller',
  ruleTypeRegex: 'regex',
  ruleDeleted: 'Regel borttagen',
  ruleAdded: 'Regel tillagd',
  ruleInvalid: 'Ange ett regelv√§rde',
  clipboardEmpty: 'Urklipp √§r tomt',
  pastePrompt: 'Tryck ‚åò/Ctrl+V f√∂r att importera JSON',
  invalidFormat: 'Ogiltigt filformat'
,
    importNote: 'Kopiera JSON till urklipp innan import. Tryck sedan ‚åò/Ctrl+V.'},
pl: {
  title: 'üõí Ukrywanie zam√≥wie≈Ñ Amazon',
  labelOrder: 'Wpisz numer zam√≥wienia:',
  placeholder: 'np. 123-4567890-1234567',
  btnHide: 'Ukryj',
  hiddenOrders: 'Ukryte zam√≥wienia',
  empty: 'Brak ukrytych zam√≥wie≈Ñ',
  btnShowAll: 'Poka≈º wszystkie',
  btnImport: 'Importuj',
  btnExport: 'Eksportuj',
  noteEnterOrder: 'Wpisz numer zam√≥wienia',
  noteTooShort: 'Numer zam√≥wienia jest za kr√≥tki',
  noteAlready: 'Ju≈º ukryte',
  noteHidden: 'Zam√≥wienie ukryte!',
  noteShown: 'Zam√≥wienie zn√≥w widoczne',
  noteAllShown: 'Wszystkie zam√≥wienia zn√≥w widoczne',
  confirmShowAll: 'Pokazaƒá wszystkie zam√≥wienia ponownie?',
  exportOk: 'Listƒô wyeksportowano',
  importOk: (n) => `Import zako≈Ñczony: ${n} pozycji`,
  importFail: 'Nieudany import: nieprawid≈Çowy plik',
  fileErr: 'B≈ÇƒÖd odczytu pliku',
  showBtn: 'Poka≈º',
  rulesTitle: 'Regu≈Çy automatycznego ukrywania',
  ruleLabel: 'Ukryj, je≈õli tytu≈Ç produktu zawiera:',
  ruleRegex: 'U≈ºyj RegExp',
  ruleHelp: 'Przyk≈Çad: ^prezent.*prime$',
  ruleAdd: 'Dodaj regu≈Çƒô',
  rulesList: 'Regu≈Çy',
  rulesEmpty: 'Brak regu≈Ç',
  ruleEnabled: 'W≈ÇƒÖczona',
  ruleTypeContains: 'zawiera',
  ruleTypeRegex: 'regex',
  ruleDeleted: 'Regu≈Ça usuniƒôta',
  ruleAdded: 'Regu≈Ça dodana',
  ruleInvalid: 'Wpisz warto≈õƒá regu≈Çy',
  clipboardEmpty: 'Schowek jest pusty',
  pastePrompt: 'Naci≈õnij ‚åò/Ctrl+V, aby zaimportowaƒá JSON',
  invalidFormat: 'Nieprawid≈Çowy format pliku'
,
    importNote: 'Przed importem skopiuj JSON do schowka. Nastƒôpnie naci≈õnij ‚åò/Ctrl+V.'},
tr: {
  title: 'üõí Amazon Sipari≈ü Gizleyici',
  labelOrder: 'Sipari≈ü numarasƒ±nƒ± girin:',
  placeholder: '√∂rn. 123-4567890-1234567',
  btnHide: 'Gizle',
  hiddenOrders: 'Gizlenen sipari≈üler',
  empty: 'Gizlenen sipari≈ü yok',
  btnShowAll: 'T√ºm√ºn√º g√∂ster',
  btnImport: 'ƒ∞√ße aktar',
  btnExport: 'Dƒ±≈üa aktar',
  noteEnterOrder: 'L√ºtfen sipari≈ü numarasƒ± girin',
  noteTooShort: 'Sipari≈ü numarasƒ± √ßok kƒ±sa',
  noteAlready: 'Zaten gizli',
  noteHidden: 'Sipari≈ü gizlendi!',
  noteShown: 'Sipari≈ü yeniden g√∂r√ºn√ºr',
  noteAllShown: 'T√ºm sipari≈üler yeniden g√∂r√ºn√ºr',
  confirmShowAll: 'T√ºm sipari≈üler yeniden g√∂sterilsin mi?',
  exportOk: 'Liste dƒ±≈üa aktarƒ±ldƒ±',
  importOk: (n) => `ƒ∞√ße aktarma ba≈üarƒ±lƒ±: ${n} kayƒ±t`,
  importFail: 'ƒ∞√ße aktarma ba≈üarƒ±sƒ±z: ge√ßersiz dosya',
  fileErr: 'Dosya okuma hatasƒ±',
  showBtn: 'G√∂ster',
  rulesTitle: 'Otomatik gizleme kurallarƒ±',
  ruleLabel: '√úr√ºn ba≈ülƒ±ƒüƒ± ≈üunlarƒ± i√ßeriyorsa gizle:',
  ruleRegex: 'RegExp kullan',
  ruleHelp: '√ñrnek: ^hediye.*prime$',
  ruleAdd: 'Kural ekle',
  rulesList: 'Kurallar',
  rulesEmpty: 'Hen√ºz kural yok',
  ruleEnabled: 'Etkin',
  ruleTypeContains: 'i√ßerir',
  ruleTypeRegex: 'regex',
  ruleDeleted: 'Kural silindi',
  ruleAdded: 'Kural eklendi',
  ruleInvalid: 'L√ºtfen bir kural deƒüeri girin',
  clipboardEmpty: 'Pano bo≈ü',
  pastePrompt: 'JSON i√ße aktarmak i√ßin ‚åò/Ctrl+V\'ye basƒ±n',
  invalidFormat: 'Dosya bi√ßimi ge√ßersiz'
,
    importNote: 'ƒ∞√ße aktarmadan √∂nce JSON‚Äôu panoya kopyalayƒ±n. Ardƒ±ndan ‚åò/Ctrl+V‚Äôye basƒ±n.'},
pt: {
  title: 'üõí Ocultar pedidos da Amazon',
  labelOrder: 'Insira o n√∫mero do pedido:',
  placeholder: 'ex. 123-4567890-1234567',
  btnHide: 'Ocultar',
  hiddenOrders: 'Pedidos ocultos',
  empty: 'Nenhum pedido oculto',
  btnShowAll: 'Mostrar todos',
  btnImport: 'Importar',
  btnExport: 'Exportar',
  noteEnterOrder: 'Insira o n√∫mero do pedido',
  noteTooShort: 'N√∫mero do pedido muito curto',
  noteAlready: 'J√° oculto',
  noteHidden: 'Pedido ocultado!',
  noteShown: 'Pedido vis√≠vel novamente',
  noteAllShown: 'Todos os pedidos vis√≠veis novamente',
  confirmShowAll: 'Mostrar todos os pedidos novamente?',
  exportOk: 'Lista exportada',
  importOk: (n) => `Importa√ß√£o conclu√≠da: ${n} itens`,
  importFail: 'Falha na importa√ß√£o: arquivo inv√°lido',
  fileErr: 'Erro ao ler o arquivo',
  showBtn: 'Mostrar',
  rulesTitle: 'Regras de oculta√ß√£o autom√°tica',
  ruleLabel: 'Ocultar se o t√≠tulo do produto contiver:',
  ruleRegex: 'Usar RegExp',
  ruleHelp: 'Exemplo: ^presente.*prime$',
  ruleAdd: 'Adicionar regra',
  rulesList: 'Regras',
  rulesEmpty: 'Nenhuma regra',
  ruleEnabled: 'Ativado',
  ruleTypeContains: 'cont√©m',
  ruleTypeRegex: 'regex',
  ruleDeleted: 'Regra removida',
  ruleAdded: 'Regra adicionada',
  ruleInvalid: 'Insira um valor de regra',
  clipboardEmpty: '√Årea de transfer√™ncia vazia',
  pastePrompt: 'Pressione ‚åò/Ctrl+V para importar JSON',
  invalidFormat: 'Formato de arquivo inv√°lido'
,
    importNote: 'Antes de importar, copie o JSON para a √°rea de transfer√™ncia. Depois pressione ‚åò/Ctrl+V.'},
ar: {
  title: 'üõí ÿ•ÿÆŸÅÿßÿ° ÿ∑ŸÑÿ®ÿßÿ™ ÿ£ŸÖÿßÿ≤ŸàŸÜ',
  labelOrder: 'ÿ£ÿØÿÆŸÑ ÿ±ŸÇŸÖ ÿßŸÑÿ∑ŸÑÿ®:',
  placeholder: 'ŸÖÿ´ÿßŸÑ: 123-4567890-1234567',
  btnHide: 'ÿ•ÿÆŸÅÿßÿ°',
  hiddenOrders: 'ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™ ÿßŸÑŸÖÿÆŸÅŸäÿ©',
  empty: 'ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ∑ŸÑÿ®ÿßÿ™ ŸÖÿÆŸÅŸäÿ©',
  btnShowAll: 'ÿπÿ±ÿ∂ ÿßŸÑŸÉŸÑ',
  btnImport: 'ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ',
  btnExport: 'ÿ™ÿµÿØŸäÿ±',
  noteEnterOrder: 'Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ÿ±ŸÇŸÖ ÿßŸÑÿ∑ŸÑÿ®',
  noteTooShort: 'ÿ±ŸÇŸÖ ÿßŸÑÿ∑ŸÑÿ® ŸÇÿµŸäÿ± ÿ¨ÿØÿßŸã',
  noteAlready: 'ŸÖŸèÿÆŸÅŸâ ŸÖÿ≥ÿ®ŸÇÿßŸã',
  noteHidden: 'ÿ™ŸÖ ÿ•ÿÆŸÅÿßÿ° ÿßŸÑÿ∑ŸÑÿ®!',
  noteShown: 'ÿ£ÿµÿ®ÿ≠ ÿßŸÑÿ∑ŸÑÿ® ŸÖÿ±ÿ¶ŸäÿßŸã ŸÖÿ¨ÿØÿØÿßŸã',
  noteAllShown: 'ÿ¨ŸÖŸäÿπ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™ ŸÖÿ±ÿ¶Ÿäÿ© ŸÖÿ¨ÿØÿØÿßŸã',
  confirmShowAll: 'ÿπÿ±ÿ∂ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™ ŸÖÿ¨ÿØÿØÿßŸãÿü',
  exportOk: 'ÿ™ŸÖ ÿ™ÿµÿØŸäÿ± ÿßŸÑŸÇÿßÿ¶ŸÖÿ©',
  importOk: (n) => `ÿ™ŸÖ ÿßŸÑÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ ÿ®ŸÜÿ¨ÿßÿ≠: ${n} ÿπŸÜÿµÿ±Ÿãÿß`,
  importFail: 'ŸÅÿ¥ŸÑ ÿßŸÑÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ: ŸÖŸÑŸÅ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠',
  fileErr: 'ÿÆÿ∑ÿ£ ŸÅŸä ŸÇÿ±ÿßÿ°ÿ© ÿßŸÑŸÖŸÑŸÅ',
  showBtn: 'ÿπÿ±ÿ∂',
  rulesTitle: 'ŸÇŸàÿßÿπÿØ ÿßŸÑÿ•ÿÆŸÅÿßÿ° ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä',
  ruleLabel: 'ÿ£ÿÆŸÅŸê ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿπŸÜŸàÿßŸÜ ÿßŸÑŸÖŸÜÿ™ÿ¨ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ:',
  ruleRegex: 'ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ RegExp',
  ruleHelp: 'ŸÖÿ´ÿßŸÑ: ^ŸáÿØŸäÿ©.*prime$',
  ruleAdd: 'ÿ•ÿ∂ÿßŸÅÿ© ŸÇÿßÿπÿØÿ©',
  rulesList: 'ÿßŸÑŸÇŸàÿßÿπÿØ',
  rulesEmpty: 'ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÇŸàÿßÿπÿØ',
  ruleEnabled: 'ŸÖŸÅÿπŸëŸÑ',
  ruleTypeContains: 'Ÿäÿ≠ÿ™ŸàŸä',
  ruleTypeRegex: 'regex',
  ruleDeleted: 'ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑŸÇÿßÿπÿØÿ©',
  ruleAdded: 'ÿ™ŸÖÿ™ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÇÿßÿπÿØÿ©',
  ruleInvalid: 'Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ŸÇŸäŸÖÿ© ŸÑŸÑŸÇÿßÿπÿØÿ©',
  clipboardEmpty: 'ÿßŸÑÿ≠ÿßŸÅÿ∏ÿ© ŸÅÿßÿ±ÿ∫ÿ©',
  pastePrompt: 'ÿßÿ∂ÿ∫ÿ∑ ‚åò/Ctrl+V ŸÑÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ JSON',
  invalidFormat: 'ÿ™ŸÜÿ≥ŸäŸÇ ŸÖŸÑŸÅ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠'
,
    importNote: 'ŸÇÿ®ŸÑ ÿßŸÑÿßÿ≥ÿ™Ÿäÿ±ÿßÿØÿå ÿßŸÜÿ≥ÿÆ JSON ÿ•ŸÑŸâ ÿßŸÑÿ≠ÿßŸÅÿ∏ÿ© ÿ´ŸÖ ÿßÿ∂ÿ∫ÿ∑ ‚åò/Ctrl+V.'},
ja: {
  title: 'üõí Amazon Ê≥®Êñá„ÇíÈùûË°®Á§∫',
  labelOrder: 'Ê≥®ÊñáÁï™Âè∑„ÇíÂÖ•Âäõ:',
  placeholder: '‰æã: 123-4567890-1234567',
  btnHide: 'ÈùûË°®Á§∫',
  hiddenOrders: 'ÈùûË°®Á§∫„ÅÆÊ≥®Êñá',
  empty: 'ÈùûË°®Á§∫„ÅÆÊ≥®Êñá„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì',
  btnShowAll: '„Åô„Åπ„Å¶Ë°®Á§∫',
  btnImport: '„Ç§„É≥„Éù„Éº„Éà',
  btnExport: '„Ç®„ÇØ„Çπ„Éù„Éº„Éà',
  noteEnterOrder: 'Ê≥®ÊñáÁï™Âè∑„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
  noteTooShort: 'Ê≥®ÊñáÁï™Âè∑„ÅåÁü≠„Åô„Åé„Åæ„Åô',
  noteAlready: '„Åô„Åß„Å´ÈùûË°®Á§∫„Åß„Åô',
  noteHidden: 'Ê≥®Êñá„ÇíÈùûË°®Á§∫„Å´„Åó„Åæ„Åó„ÅüÔºÅ',
  noteShown: 'Ê≥®Êñá„ÇíÂÜçË°®Á§∫„Åó„Åæ„Åó„Åü',
  noteAllShown: '„Åô„Åπ„Å¶„ÅÆÊ≥®Êñá„ÇíÂÜçË°®Á§∫„Åó„Åæ„Åó„Åü',
  confirmShowAll: '„Åô„Åπ„Å¶„ÅÆÊ≥®Êñá„ÇíÂÜçË°®Á§∫„Åó„Åæ„Åô„ÅãÔºü',
  exportOk: '„É™„Çπ„Éà„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Åæ„Åó„Åü',
  importOk: (n) => `„Ç§„É≥„Éù„Éº„Éà„Å´ÊàêÂäü: ${n} ‰ª∂`,
  importFail: '„Ç§„É≥„Éù„Éº„Éà„Å´Â§±Êïó: ÁÑ°Âäπ„Å™„Éï„Ç°„Ç§„É´',
  fileErr: '„Éï„Ç°„Ç§„É´„ÅÆË™≠„ÅøÂèñ„Çä„Ç®„É©„Éº',
  showBtn: 'Ë°®Á§∫',
  rulesTitle: 'Ëá™ÂãïÈùûË°®Á§∫„É´„Éº„É´',
  ruleLabel: 'ÂïÜÂìÅ„Çø„Ç§„Éà„É´„Å´Ê¨°„ÅåÂê´„Åæ„Çå„ÇãÂ†¥Âêà„ÅØÈùûË°®Á§∫:',
  ruleRegex: 'RegExp „Çí‰ΩøÁî®',
  ruleHelp: '‰æã: ^gift.*prime$',
  ruleAdd: '„É´„Éº„É´„ÇíËøΩÂä†',
  rulesList: '„É´„Éº„É´',
  rulesEmpty: '„É´„Éº„É´„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì',
  ruleEnabled: 'ÊúâÂäπ',
  ruleTypeContains: 'Âê´„ÇÄ',
  ruleTypeRegex: 'regex',
  ruleDeleted: '„É´„Éº„É´„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü',
  ruleAdded: '„É´„Éº„É´„ÇíËøΩÂä†„Åó„Åæ„Åó„Åü',
  ruleInvalid: '„É´„Éº„É´„ÅÆÂÄ§„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
  clipboardEmpty: '„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„ÅØÁ©∫„Åß„Åô',
  pastePrompt: 'JSON „Çí„Ç§„É≥„Éù„Éº„Éà„Åô„Çã„Å´„ÅØ ‚åò/Ctrl+V „ÇíÊäº„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
  invalidFormat: 'ÁÑ°Âäπ„Å™„Éï„Ç°„Ç§„É´ÂΩ¢Âºè„Åß„Åô'
,
    importNote: '„Ç§„É≥„Éù„Éº„ÉàÂâç„Å´ JSON „Çí„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº„Åó„ÄÅ„Åù„ÅÆÂæå ‚åò/Ctrl+V „ÇíÊäº„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'},
zh: {
  title: 'üõí ÈöêËóè‰∫öÈ©¨ÈÄäËÆ¢Âçï',
  labelOrder: 'ËæìÂÖ•ËÆ¢ÂçïÂè∑Ôºö',
  placeholder: '‰æãÂ¶Ç 123-4567890-1234567',
  btnHide: 'ÈöêËóè',
  hiddenOrders: 'Â∑≤ÈöêËóèÁöÑËÆ¢Âçï',
  empty: 'ÊöÇÊó†ÈöêËóèËÆ¢Âçï',
  btnShowAll: 'ÊòæÁ§∫ÂÖ®ÈÉ®',
  btnImport: 'ÂØºÂÖ•',
  btnExport: 'ÂØºÂá∫',
  noteEnterOrder: 'ËØ∑ËæìÂÖ•ËÆ¢ÂçïÂè∑',
  noteTooShort: 'ËÆ¢ÂçïÂè∑ËøáÁü≠',
  noteAlready: 'Â∑≤ÈöêËóè',
  noteHidden: 'ËÆ¢ÂçïÂ∑≤ÈöêËóèÔºÅ',
  noteShown: 'ËÆ¢ÂçïÂ∑≤ÈáçÊñ∞ÂèØËßÅ',
  noteAllShown: 'ÊâÄÊúâËÆ¢ÂçïÂ∑≤ÈáçÊñ∞ÂèØËßÅ',
  confirmShowAll: 'Á°ÆÂÆöÈáçÊñ∞ÊòæÁ§∫ÊâÄÊúâËÆ¢ÂçïÔºü',
  exportOk: 'ÂàóË°®Â∑≤ÂØºÂá∫',
  importOk: (n) => `ÂØºÂÖ•ÊàêÂäüÔºö${n} Êù°`,
  importFail: 'ÂØºÂÖ•Â§±Ë¥•ÔºöÊó†ÊïàÊñá‰ª∂',
  fileErr: 'Êñá‰ª∂ËØªÂèñÈîôËØØ',
  showBtn: 'ÊòæÁ§∫',
  rulesTitle: 'Ëá™Âä®ÈöêËóèËßÑÂàô',
  ruleLabel: 'ÂΩìÂïÜÂìÅÊ†áÈ¢òÂåÖÂê´‰ª•‰∏ãÂÜÖÂÆπÊó∂ÈöêËóèÔºö',
  ruleRegex: '‰ΩøÁî® RegExp',
  ruleHelp: 'Á§∫‰æãÔºö^gift.*prime$',
  ruleAdd: 'Ê∑ªÂä†ËßÑÂàô',
  rulesList: 'ËßÑÂàô',
  rulesEmpty: 'ÊöÇÊó†ËßÑÂàô',
  ruleEnabled: 'Â∑≤ÂêØÁî®',
  ruleTypeContains: 'ÂåÖÂê´',
  ruleTypeRegex: 'Ê≠£Âàô',
  ruleDeleted: 'ËßÑÂàôÂ∑≤Âà†Èô§',
  ruleAdded: 'ËßÑÂàôÂ∑≤Ê∑ªÂä†',
  ruleInvalid: 'ËØ∑ËæìÂÖ•ËßÑÂàôÂÄº',
  clipboardEmpty: 'Ââ™Ë¥¥Êùø‰∏∫Á©∫',
  pastePrompt: 'Êåâ ‚åò/Ctrl+V ‰ª•ÂØºÂÖ• JSON',
  invalidFormat: 'Êñá‰ª∂Ê†ºÂºèÊó†Êïà'
,
    importNote: 'ÂØºÂÖ•ÂâçÂÖàÂ∞Ü JSON Â§çÂà∂Âà∞Ââ™Ë¥¥ÊùøÔºåÁÑ∂ÂêéÊåâ ‚åò/Ctrl+V„ÄÇ'}
};

let L = I18N.en;
const qs = (sel) => document.querySelector(sel);
function I18NText(key, ...args) { const v = L[key]; return typeof v === 'function' ? v(...args) : v; }

function detectLocaleFromActiveTab() {
  return api.tabs.query({ active: true, currentWindow: true }).then((tabs) => {
    const url = tabs[0]?.url || '';
    try {
      const host = new URL(url).hostname;
      const key = Object.keys(DOMAIN_LOCALE).find(d => host.endsWith(d));
      return DOMAIN_LOCALE[key] || null;
    } catch { return null; }
  });
}

async function applyI18n() {
  const loc = await detectLocaleFromActiveTab();
  const nav = (navigator.language || 'en').slice(0,2).toLowerCase();
  const lang = (loc && I18N[loc]) ? loc : (I18N[nav] ? nav : 'en');
  L = I18N[lang];

  qs('#i18n-title').textContent = L.title;
  qs('#i18n-label-order').textContent = L.labelOrder;
  qs('#order-number').placeholder = L.placeholder;
  qs('#i18n-btn-hide').textContent = L.btnHide;
  qs('#i18n-hidden-orders').textContent = L.hiddenOrders;
  qs('#i18n-empty').textContent = L.empty;
  qs('#i18n-btn-showall').textContent = L.btnShowAll;
  qs('#i18n-btn-import').textContent = L.btnImport;
  qs('#i18n-btn-export').textContent = L.btnExport;

  // import note below the three buttons (no title)
  const noteEl = document.getElementById('i18n-import-note');
  if (noteEl && L.importNote) noteEl.textContent = L.importNote;


  // rules (falls UI vorhanden)
  const el = (id) => qs(id) || { textContent: '' };
  el('#i18n-rules-title').textContent = L.rulesTitle || 'Auto‚ÄëHide rules';
  el('#i18n-rule-label').textContent = L.ruleLabel || 'Hide if product title contains:';
  el('#i18n-rule-regex').textContent = L.ruleRegex || 'Use RegExp';
  el('#i18n-rule-help').textContent = L.ruleHelp || 'Example: ^gift.*prime$';
  el('#i18n-rule-add').textContent = L.ruleAdd || 'Add rule';
  el('#i18n-rules-list').textContent = L.rulesList || 'Rules';
  el('#i18n-rules-empty').textContent = L.rulesEmpty || 'No rules yet';
}

// ---- Orders ----
function loadHiddenOrders() {
  api.storage.local.get(['hiddenOrders', 'hiddenMeta']).then((res) => {
    const hiddenOrders = res.hiddenOrders || [];
    const hiddenMeta = res.hiddenMeta || {};
    displayHiddenOrders(hiddenOrders, hiddenMeta);
    api.runtime.sendMessage({ action: 'updateBadge' }).catch(() => {});
  });
}

function displayHiddenOrders(orders, meta) {
  const list = document.getElementById('hidden-orders-list');
  list.innerHTML = '';
  if (!orders.length) {
    const p = document.createElement('p');
    p.className = 'empty-state';
    p.textContent = L.empty;
    list.appendChild(p);
    return;
  }
  orders.forEach((orderNo) => {
    const title = meta?.[orderNo]?.title || '';
    const display = title ? truncate(title, 70) : orderNo;

    const row = document.createElement('div');
    row.className = 'order-item';
    row.innerHTML = `
      <div class="order-title">${escapeHtml(display)}</div>
      <button class="remove-btn" data-order="${escapeHtml(orderNo)}">${escapeHtml(L.showBtn)}</button>
      ${title ? `<div class="order-sub">${escapeHtml(orderNo)}</div>` : ''}
    `;
    list.appendChild(row);
  });
  list.querySelectorAll('.remove-btn').forEach((btn) => {
    btn.addEventListener('click', function () { removeOrder(this.getAttribute('data-order')); });
  });
}

function refreshMetaFromPage() {
  api.tabs.query({ active: true, currentWindow: true }).then((tabs) => {
    const tab = tabs[0];
    if (!tab) return;
    api.tabs.sendMessage(tab.id, { action: 'collectOrderMeta' }).catch(() => {});
    setTimeout(() => {
      api.tabs.sendMessage(tab.id, { action: 'applyAutoRules' }).catch(() => {});
      loadHiddenOrders();
    }, 500);
  });
}

function hideOrder() {
  const input = document.getElementById('order-number');
  const orderNumber = input.value.trim();
  if (!orderNumber) return showNotification(L.noteEnterOrder, 'error');
  if (orderNumber.length < 5) return showNotification(L.noteTooShort, 'error');

  api.storage.local.get('hiddenOrders').then((res) => {
    const hiddenOrders = res.hiddenOrders || [];
    if (hiddenOrders.includes(orderNumber)) return showNotification(L.noteAlready, 'warning');

    hiddenOrders.push(orderNumber);
    api.storage.local.set({ hiddenOrders }).then(() => {
      input.value = '';
      loadHiddenOrders();
      showNotification(L.noteHidden, 'success');

      api.tabs.query({ active: true, currentWindow: true }).then((tabs) => {
        const tab = tabs[0]; if (!tab) return;
        api.tabs.sendMessage(tab.id, { action: 'updateHiddenOrders' }).catch(() => {});
        api.tabs.sendMessage(tab.id, { action: 'collectOrderMeta' }).catch(() => {});
        setTimeout(() => {
          api.tabs.sendMessage(tab.id, { action: 'applyAutoRules' }).catch(() => {});
          loadHiddenOrders();
        }, 500);
      });
    });
  });
}

function removeOrder(orderNumber) {
  api.storage.local.get(['hiddenOrders']).then((res) => {
    let hiddenOrders = res.hiddenOrders || [];
    hiddenOrders = hiddenOrders.filter((o) => o !== orderNumber);
    api.storage.local.set({ hiddenOrders }).then(async () => {
      await pruneHiddenMeta().catch(() => {});
      loadHiddenOrders();
      showNotification(L.noteShown, 'success');

      api.tabs.query({ active: true, currentWindow: true }).then((tabs) => {
        const tab = tabs[0]; if (!tab) return;
        api.tabs.sendMessage(tab.id, { action: 'updateHiddenOrders' }).catch(() => {});
        setTimeout(loadHiddenOrders, 300);
      });
    });
  });
}

function clearAllOrders() {
  if (!confirm(L.confirmShowAll)) return;
  api.storage.local.set({ hiddenOrders: [] }).then(async () => {
    await api.storage.local.set({ hiddenMeta: {} }).catch(() => {}); // Privacy: Metadaten leeren
    loadHiddenOrders();
    showNotification(L.noteAllShown, 'success');
    api.tabs.query({ active: true, currentWindow: true }).then((tabs) => {
      const tab = tabs[0]; if (!tab) return;
      api.tabs.sendMessage(tab.id, { action: 'updateHiddenOrders' }).catch(() => {});
      setTimeout(loadHiddenOrders, 300);
    });
  });
}

// --- Helper: nur Metadaten f√ºr aktuell verborgene Bestellungen behalten ---
async function pruneHiddenMeta() {
  const { hiddenOrders = [], hiddenMeta = {} } = await api.storage.local.get(['hiddenOrders', 'hiddenMeta']);
  if (!hiddenOrders.length) {
    if (Object.keys(hiddenMeta).length) {
      await api.storage.local.set({ hiddenMeta: {} });
    }
    return {};
  }
  const set = new Set(hiddenOrders);
  const filtered = {};
  for (const [orderNo, meta] of Object.entries(hiddenMeta)) {
    if (set.has(orderNo)) filtered[orderNo] = meta;
  }
  if (Object.keys(filtered).length !== Object.keys(hiddenMeta).length) {
    await api.storage.local.set({ hiddenMeta: filtered });
  }
  return filtered;
}

// ---- Export (Privacy: nur Meta der versteckten Bestellungen) ----
async function exportList() {
  const filteredMeta = await pruneHiddenMeta();
  const { hiddenOrders = [], autoRules = [] } = await api.storage.local.get(['hiddenOrders', 'autoRules']);

  const exportData = {
    exportDate: new Date().toISOString(),
    hiddenOrders: hiddenOrders || [],
    hiddenMeta: filteredMeta || {},
    autoRules: autoRules || []
  };

  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `amazon-hidden-orders-${Date.now()}.json`;
  a.click();
  setTimeout(() => URL.revokeObjectURL(url), 0);
  showNotification(L.exportOk, 'success');
}

// ======================= Import ‚Äì nur Zwischenablage ========================

// Klick auf "Import": Wenn Clipboard leer -> Meldung leer,
// sonst -> Prompt "Bitte ‚åò/Strg+V dr√ºcken" und Fokus auf verstecktes Paste-Ziel.
async function importList() {
  try {
    const hasItems = await clipboardHasAnyData();
    if (!hasItems) {
      showNotification(L.clipboardEmpty || 'Clipboard is empty', 'warning');
      return;
    }
    // Clipboard hat etwas -> Nutzer soll (wie gew√ºnscht) CMD/Strg+V dr√ºcken
    showNotification(L.pastePrompt || 'Press ‚åò/Ctrl+V to paste JSON‚Ä¶', 'warning');
    focusHiddenPasteTarget();
  } catch {
    // Wenn wir gar nicht pr√ºfen k√∂nnen, verhalten wir uns wie "nicht leer" -> Prompt
    showNotification(L.pastePrompt || 'Press ‚åò/Ctrl+V to paste JSON‚Ä¶', 'warning');
    focusHiddenPasteTarget();
  }
}

// Pr√ºft, ob prinzipiell etwas in der Zwischenablage liegt (Blob oder Text)
async function clipboardHasAnyData() {
  // Versuch 1: ClipboardItem (kann auch bei Dateikopie Items liefern)
  if (navigator.clipboard?.read) {
    try {
      const items = await navigator.clipboard.read();
      if (Array.isArray(items) && items.length > 0) return true;
    } catch {/* still try text */}
  }
  // Versuch 2: Text
  if (navigator.clipboard?.readText) {
    try {
      const txt = await navigator.clipboard.readText();
      if (txt && txt.trim().length > 0) return true;
    } catch {/* ignore */}
  }
  return false;
}

// Globaler Paste-Handler: Datei-JSON oder JSON-Text importieren.
// - Datei vorhanden, aber NICHT JSON -> "Dateiformat ist falsch"
async function handleGlobalPaste(e) {
  try {
    const dt = e.clipboardData;
    if (!dt) return;

    // 1) Dateien?
    if (dt.files && dt.files.length) {
      const jsonFile = pickJsonFile(dt.files);
      if (jsonFile) {
        const text = await jsonFile.text();
        const data = parseJsonRelaxed(text);
        await processImportedData(data);
        e.preventDefault();
        return;
      } else {
        // Datei vorhanden, aber nicht JSON
        showNotification(L.invalidFormat || 'File format is invalid', 'error');
        e.preventDefault();
        return;
      }
    }

    // 2) Items (manche Browser liefern Dateien hier)
    const items = dt.items ? Array.from(dt.items) : [];
    const fileItems = items.filter(it => it.kind === 'file');
    if (fileItems.length) {
      // Gibt es eine JSON-Datei unter den Items?
      for (const it of fileItems) {
        const f = it.getAsFile();
        if (!f) continue;
        const jf = pickJsonFile([f]);
        if (jf) {
          const text = await jf.text();
          const data = parseJsonRelaxed(text);
          await processImportedData(data);
          e.preventDefault();
          return;
        }
      }
      // Nur Dateien, aber keine JSON-Datei
      showNotification(L.invalidFormat || 'File format is invalid', 'error');
      e.preventDefault();
      return;
    }

    // 3) Reiner Text?
    const txt = dt.getData('text/plain') || '';
    if (looksLikeJson(txt)) {
      try {
        const data = parseJsonRelaxed(txt);
        await processImportedData(data);
        e.preventDefault();
        return;
      } catch {
        showNotification(L.invalidFormat || 'File format is invalid', 'error');
        e.preventDefault();
        return;
      }
    }
    // Kein JSON -> normalen Paste nicht st√∂ren
  } catch (err) {
    console.error('paste import failed:', err);
    showNotification(L.importFail || 'Import failed: invalid file', 'error');
  }
}

// Unsichtbares, fokusierbares Ziel f√ºr CMD/Strg+V (kein Overlay)
function focusHiddenPasteTarget() {
  let el = document.getElementById('paste-capture');
  if (!el) {
    el = document.createElement('div');
    el.id = 'paste-capture';
    el.setAttribute('contenteditable', 'true');
    el.style.cssText = 'position:absolute;left:-9999px;top:0;width:1px;height:1px;opacity:0;pointer-events:none;';
    document.body.appendChild(el);
  }
  try { el.focus({ preventScroll: true }); } catch {}
}

// Datei-Erkennung
function pickJsonFile(fileList) {
  const arr = Array.from(fileList || []);
  return arr.find(f =>
    f && (
      f.type === 'application/json' ||
      f.type === 'text/json' ||
      f.type === 'application/x-json' ||
      /\.json$/i.test(f.name || '')
    )
  ) || null;
}

// ======================= Import-Pipeline ====================================
async function processImportedData(data) {
  // ---- Eingabedaten normalisieren ----
  let importedOrders = [];
  let importedMeta = {};
  let importedRules = [];

  if (Array.isArray(data)) {
    importedOrders = data;
  } else if (data && typeof data === 'object') {
    if (Array.isArray(data.hiddenOrders)) importedOrders = data.hiddenOrders;
    else if (Array.isArray(data.orders)) importedOrders = data.orders; // Fallback
    if (data.hiddenMeta && typeof data.hiddenMeta === 'object') importedMeta = data.hiddenMeta;
    if (Array.isArray(data.autoRules)) importedRules = data.autoRules;
  } else {
    throw new Error('Invalid format: root must be array or object');
  }

  importedOrders = (importedOrders || [])
    .filter(x => typeof x === 'string')
    .map(x => x.trim())
    .filter(Boolean);

  // ---- Aktuellen Speicher lesen ----
  const { hiddenOrders: curOrders = [], hiddenMeta: curMeta = {}, autoRules: curRules = [] } =
    await api.storage.local.get(['hiddenOrders','hiddenMeta','autoRules']);

  // ---- Mergen ----
  const mergedOrders = Array.from(new Set([...curOrders, ...importedOrders]));
  const orderSet = new Set(mergedOrders);

  // Metadaten nur f√ºr Bestellungen behalten, die auch in mergedOrders existieren
  const cleanedImportedMeta = {};
  for (const [orderNo, meta] of Object.entries(importedMeta || {})) {
    if (orderSet.has(orderNo) && meta && typeof meta === 'object') cleanedImportedMeta[orderNo] = meta;
  }
  const cleanedCurrentMeta = {};
  for (const [orderNo, meta] of Object.entries(curMeta || {})) {
    if (orderSet.has(orderNo)) cleanedCurrentMeta[orderNo] = meta;
  }
  const mergedMeta = { ...cleanedCurrentMeta, ...cleanedImportedMeta };

  const mergedRules = [...curRules, ...(importedRules || [])];

  await api.storage.local.set({
    hiddenOrders: mergedOrders,
    hiddenMeta: mergedMeta,
    autoRules: mergedRules
  });

  // ---- UI + Seite aktualisieren ----
  loadHiddenOrders();
  showNotification(I18NText('importOk', importedOrders.length), 'success');

  try {
    const [{ id: tabId } = {}] = await api.tabs.query({ active: true, currentWindow: true });
    if (tabId) {
      await api.tabs.sendMessage(tabId, { action: 'updateHiddenOrders' });
      await api.tabs.sendMessage(tabId, { action: 'collectOrderMeta' });
      setTimeout(() => api.tabs.sendMessage(tabId, { action: 'applyAutoRules' }).catch(() => {}), 300);
    }
  } catch (e) {
    console.debug('Post-import tab message skipped:', e?.message);
  }
}

// ======================= Rules UI ===========================================
function loadRules() {
  api.storage.local.get('autoRules').then((res) => {
    const rules = res.autoRules || [];
    renderRules(rules);
  });
}

function renderRules(rules) {
  const wrap = document.getElementById('rules-list');
  if (!wrap) return; // falls √§ltere popup.html ohne Rules
  wrap.innerHTML = '';
  if (!rules.length) {
    const p = document.createElement('p');
    p.className = 'empty-state';
    p.textContent = L.rulesEmpty || 'No rules yet';
    wrap.appendChild(p);
    return;
  }
  rules.forEach((r, idx) => {
    const row = document.createElement('div');
    row.className = 'order-item';
    row.innerHTML = `
      <div class="order-title">
        <strong>[${escapeHtml(r.type === 'regex' ? (L.ruleTypeRegex || 'regex') : (L.ruleTypeContains || 'contains'))}]</strong>
        <span style="margin-left:6px">${escapeHtml(r.pattern)}</span>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <label style="display:flex;align-items:center;gap:6px;font-size:12px;color:#495057">
          <input type="checkbox" data-idx="${idx}" class="rule-toggle" ${r.enabled ? 'checked' : ''} />
          ${escapeHtml(L.ruleEnabled || 'Enabled')}
        </label>
        <button class="remove-btn" data-idx="${idx}">‚úñ</button>
      </div>
    `;
    wrap.appendChild(row);
  });

  wrap.querySelectorAll('.rule-toggle').forEach(el => {
    el.addEventListener('change', (e) => toggleRule(Number(e.target.getAttribute('data-idx')), e.target.checked));
  });
  wrap.querySelectorAll('.remove-btn').forEach(btn => {
    btn.addEventListener('click', () => deleteRule(Number(btn.getAttribute('data-idx'))));
  });
}

function addRule() {
  const txt = document.getElementById('rule-text');
  const pat = txt?.value?.trim?.() || '';
  if (!pat) return showNotification(L.ruleInvalid || 'Please enter a rule value', 'error');
  const regex = (document.getElementById('rule-regex')?.checked) || false;
  const rule = { id: Date.now(), enabled: true, type: regex ? 'regex' : 'contains', pattern: pat };

  api.storage.local.get('autoRules').then((res) => {
    const rules = res.autoRules || [];
    rules.push(rule);
    api.storage.local.set({ autoRules: rules }).then(() => {
      if (txt) txt.value = '';
      loadRules();
      showNotification(L.ruleAdded || 'Rule added', 'success');
      api.tabs.query({ active: true, currentWindow: true }).then((tabs) => {
        const tab = tabs[0]; if (!tab) return;
        api.tabs.sendMessage(tab.id, { action: 'applyAutoRules' }).catch(() => {});
      });
    });
  });
}

function toggleRule(idx, enabled) {
  api.storage.local.get('autoRules').then((res) => {
    const rules = res.autoRules || [];
    if (!rules[idx]) return;
    rules[idx].enabled = !!enabled;
    api.storage.local.set({ autoRules: rules }).then(() => {
      api.tabs.query({ active: true, currentWindow: true }).then((tabs) => {
        const tab = tabs[0]; if (!tab) return;
        api.tabs.sendMessage(tab.id, { action: 'applyAutoRules' }).catch(() => {});
      });
    });
  });
}

function deleteRule(idx) {
  api.storage.local.get('autoRules').then((res) => {
    const rules = res.autoRules || [];
    rules.splice(idx, 1);
    api.storage.local.set({ autoRules: rules }).then(() => {
      loadRules();
      showNotification(L.ruleDeleted || 'Rule deleted', 'success');
      api.tabs.query({ active: true, currentWindow: true }).then((tabs) => {
        const tab = tabs[0]; if (!tab) return;
        api.tabs.sendMessage(tab.id, { action: 'applyAutoRules' }).catch(() => {});
      });
    });
  });
}

// ---- Utils ----
const truncate = (s, n) => (s.length > n ? s.slice(0, n - 1) + '‚Ä¶' : s);
function escapeHtml(text) { const div = document.createElement('div'); div.textContent = text; return div.innerHTML; }
function showNotification(message, type) {
  const existing = document.querySelector('.notification'); if (existing) existing.remove();
  const el = document.createElement('div');
  el.className = `notification ${type}`;
  el.textContent = message;
  el.style.cssText = `position: fixed; top: 10px; right: 10px; padding: 10px 15px; border-radius: 6px; color: white; font-size: 14px; z-index: 1000; animation: slideIn 0.3s ease;`;
  const colors = { success: '#28a745', error: '#dc3545', warning: '#ffc107' };
  el.style.background = colors[type] || colors.success;
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 5000);
}
const style = document.createElement('style');
style.textContent = `@keyframes slideIn { from{transform:translateX(100%);opacity:0;} to{transform:translateX(0);opacity:1;} }`;
document.head.appendChild(style);

// JSON tolerant parsen (BOM, Kommentare, trailing commas)
function parseJsonRelaxed(text) {
  try { return JSON.parse(text); } catch {}
  const cleaned = String(text || '')
    .replace(/^\uFEFF/, '')                       // BOM
    .replace(/\/\*[\s\S]*?\*\/|\/\/[^\n\r]*/g, '')// Kommentare
    .replace(/,\s*([}\]])/g, '$1')                // trailing comma
    .trim();
  return JSON.parse(cleaned);
}
function looksLikeJson(s) {
  if (!s) return false;
  const t = String(s).trim();
  return t.startsWith('{') || t.startsWith('[');
}